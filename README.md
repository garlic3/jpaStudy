# jpaStudy

참고문헌 : 자바 ORM 표준 JPA 프로그래밍

ORM (Object Relational Mapping)
  - 객체와 관계형 데이터베이스 연결
 
JPA (Java Persistence API)
  - 자바 진영의 ORM 기술 표준 명세
  - 기존 객체와 관계형 데이터 베이스의 패러다임 불일치 문제 해소
  - 1. 생산성, 2. 유지보수, 3. 패러다임의 불일치 해결, 4. 성능 향상, 5. 데이터 접근 추상화와 벤더 독립성
  
객체와 관계형 데이터 베이스
  - 객체 : 참조를 통해 다른 객체와 연관관계를 가짐, 연관된 객체를 참조를 통해 조회
  - 테이블 : 외래키(FK)를 통해 다른 테이블과 연관관계를 가짐, 연관된 테이블을 조인을 통해 조회

1. META-INF/persistence.xml를 통해 설정정보 조회 
2. EntityManagerFactory 생성
3. EntityManager 생성
4. EntityManager가 커넥션 풀의 커넥션 사용(트랜잭션 시작)

EntityManagerFactroy(엔티티 매니저 팩토리)
  - 애플리케이션 전체에서 공유
  - EntityManager 생성

EntityManager(엔티티 매니저)
  - 동시성의 문제로 스레드간의 공유하지 않음
  - DB 연결이 필요한 시점에서 커넥션을 얻음
  
영속성 컨텍스트(Persistence Context)
  - 엔티티 영구 저장 환경
  - 엔티티 매니저가 영속성 컨텍스트에 엔티티를 보관하고 관리
  - 1개의 엔티티 매니저 1개의 영속성 컨텍스트
  
엔티티의 생명주기
  - 비영속(new/transient) : 엔티티 객체 생성, 영속성 컨텍스트의 관리전 상태.
  - 영속(managed) : 엔티티 매니저를 통해서 엔티티 영속성 컨텍스트 저장. 영속성 컨텍스트가 관리상태.
    * JPQL을 통해 조회한 엔티티도 영속상태.
  - 준영속(detached) : 영속성 컨텍스트가 관리하던 엔티티를 영속성 컨텍스트가 관리하지 않은 상태.
  - 삭제(removed) :

...

연관관계 매핑
  - 일대일
      - 단방향
      - 양방향
  - 일대다
      - 단방향
      - 양방향
  - 다대일
      - 단방향
      - 양방향
  - 다대다
      - 양방향
      - 

상속관계 매핑
  - 각각의 테이블로 변환 (조인 전략)
  - 통합 테이블로 변환 (단일 테이블 전략)
  - 서브타입 테이블로 변환 (테이블 전략)

조인 전략
  - 엔티티 각각을 테이블로 만들고, 자식 테이블이 부모 테이블의 기본키를 (기본키 + 외래키)로 사용하는 전략
  - 조회할때 조인이 사용된다
  - 타입을 구분하는 컬럼을 추가해야 한다
  - 장점: 테이블 정규화, 외래키 참조 무결성 제약조건 활용, 저장공간을 효율적 사용
  - 단점: 조인이 많으므로 성능저하 가능성, 조회 쿼리 복잡, INSERT 쿼리 2번 실행
  - @PrimaryKeyJoinColumn, @DiscriminatorColumn, @DiscriminatorValue

단일 테이블 전략
  - 테이블을 하나만 사용(테이블 하나에 모든것을 통합)
  - 구분컬럼으로 자식 데이터를 구분
  - 조회할때 조인을 사용하지 않는다 
  - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용
  - 장점: 조인이 필요없어 조회 성능이 빠름, 조회 쿼리 단순
  - 단점: 자식엔티티가 매핑한 컬럼은 null 허용, 테이블이 커져 조희성능이 저하될수 있음
  - 구분 컬럼 필수

구현클래스마다 테이블 전략
  - 자식 엔티티마다 테이블을 만든다
  - 장점: 서브타입을 구분해서 처리할때 효과적, not null 제약조건 사용가능
  - 단점: 여러 자식 테이블 조회시(UNION) 성능저하, 자식 테이블 통합해서 쿼리작성 어려움
  - 구분 컬럼을 사용하지 않는다
  - 비추천 전략

@MappedSuperClass
  - 실제 테이블과 매핑되지 않는다(매핑 정보를 상속할 목적으로 사용)
  - @AttributeOverrides : 상속받은 매핑정보 재정의
  - @AssociationOverrides : 상속받은 연관관계 재정의
  - @MappedSuperClass 로 지정한 클래스는 엔티티가 아니므로 em.find(), JPQL에서 사용 불가
  - 추상 클래스로 만드는것을 권장
  - 등록일자, 수정일자, 등록자, 수정자같은 여러 엔티티에서 공통으로 사용하는 속성을 효율적으로 관리할수 있음

복합키와 식별 관계 매핑
  - 식별 관계 : 부모 테이블의 기본키를 자식테이블의 기본키 + 외래키로 사용하는 관계
  - 비식별 관계 : 부모 테이블의 기본키를 자식테이블의 외래키로만 사용하는 관계
      - 필수적 비식별 관계 : 외래키에 NULL 허용 X. 연관관계 필수
      - 선택적 비식별 관계 : 외래키에 NULL 허용 O. 연관관계 필수 X
  - JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 한다

@IdClass,@EmbededId 
  - @IdClass : 데이터베이스 방법
  - @EmbededId : 객체지향적 방법
  - 복합키 사용시 식별자 클래스는 반드시 equals(), hashCode()를 재정의 해야한다
  - 영속성 컨텍스트가 엔티티의 식별자를 키로 사용해서 엔티티를 관리하며, 식별자를 비교할때
    equals(), hashCode() 메소드를 사용한다

식별 관계
  - 자식 테이블의 기본키 컬럼이 늘어난다(조인 SQL 복잡, 기본키 인덱스가 불필요하게 커짐)
  - 2개 이상의 컬럼을 합해 복합 기본키를 만들어야 하는 경우 사용
  - 비즈니스 의미가 있는 자연키 컬럼을 조합해서 기본키로 주로 사용

비식별 관계
  - 비즈니스와 전혀 관계없는 대리키를 주로 기본키로 사용

프록시 초기화 과정
  - 프록시 객체에 getter를 호출해 실제 데이터를 조회
  - 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청(초기화)
  - 영속성 컨텍스트가 데이터베이스를 조회해 실제 엔티티 객체를 생성
  - 프록시 객체는 생성된 실제 엔티티 객체의 참조를 target에 저장
  - 프록시 객체는 실제 엔티티 객체의 getter를 호출해 결과를 반환

프록시의 특징 
  - 프록시 객체는 처음 사용할때 한번만 초기화된다
  - 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 주의
  - 영속성 컨텍스트에 존재하는 엔티티는 프록시를 호출해도 실제 엔티티를 반환
  - 준영속 상태의 프록시 초기화시 문제발생(영속성 컨텍스트가 초기화를 도움)

즉시로딩과 지연로딩
  - 즉시로딩 : 엔티티를 조회할때 연관된 엔티티도 함께 조회한다(fetch = FetchType.EAGER)
    하이버네이트는 SQL 조인을 사용해서 한번에 조회한다
  - 지연로딩 : 연관된 엔티티를 실제 사용할때 조회한다(fetch = FetchType.LAZY)
    연관된 엔티티를 프록시로 조회하며 프록시를 실제 사용할때 초기화하면서 데이터베이스를 조회한다

JPA 기본 페치 전략
  - @ManyToOne, @OneToOne : 즉시 로딩(FetchType.EAGER).
    optional=false (내부조인), optional=true (외부조인)
  - @OneToMany, @ManyToMany : 지연 로딩(FetchType.LAZY)
    optional=false (외부조인), optional=true (외부조인)
  - 연관된 엔티티가 컬렉션이면 지연로딩
  - 먼저 모든 연관관계에서 지연로딩으로 사용 -> 즉시로딩이 필요한곳을 분석해서 최적화

영속성 전이(CASCADE)
  - 부모 엔티티를 저장할때 자식 엔티티도 함께 저장할수 있다

고아 객체(ORPHAN)
  - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제한다
